#include "Classes.h"			//объявление классов

/************************************************************************\
|*  Г Л О Б А Л Ь Н Ы Е    П Е Р Е М Е Н Н Ы Е   И   К О Н С Т А Н Т Ы  *|
\************************************************************************/

const int GRAPHSIZE = 250;		//размер графика
const int X0 = 50;				//отступ для графика слева
const int Y0 = 77;				//отступ для графика сверху
const double EPS = 0.001;		//точность вычислений
const int MARGIN = 15;			//отступ для рамки графика

Func* ActiveFunc;				//объект для построения графика

/************************************************************************\
|*                 Р Е А Л И З А Ц И Я   М Е Т О Д О В                  *|
\************************************************************************/
/*------------------------------------*\
|          Методы класса Func          |
\*------------------------------------*/
//конструктор
Func::Func(
	double InitA,				//левая граница отрезка
	double InitB) {				//правая граница отрезка

	//инициализация закрытых полей этого класса
	A = InitA;
	B = InitB;

}//end Func::Func()

//установить отрезок
void Func::SetAB(
	double newA,				//новая левая граница отрезка
	double newB) {				//новая правая граница отрезка

	A = newA;
	B = newB;
	if (A > B) {				//если левая граница больше правой
		//поменять гранцы местами
		A = A + B;
		B = A - B;
		A -= B;
	}//end if

}//end Func::SetAB()

//получить левую границу отрезка
double Func::GetA(void) {
	return A;

}//end Func::GetA()

//получить правую границу отрезка
double Func::GetB(void) {
	return B;

}//end Func::GetB()

//получить формулу f(x)
string Func::GetfName(void) {
	return fName;

}//end Func::GetfName()

//получить формулу f'(x)
string Func::GetdfName(void) {
	return dfName;

}//end Func::GetdfName()

//получить газвание цвета графика
string Func::GetColName(void) {
	return colName;

}//end Func::GetColName()

//обработка команд пользователя
void Func::Caller(
	int mode, 					//режим работы
	double param1, 				//первый параметр
	double param2,				//второй параметр
	double param3){				//третий параметр
	double OriginA;				//исходная левая граница отрезка
	double OriginB;				//исходная правая граница отрезка
	double x, y;				//координаты точки

	switch (mode) {				//выбор метода в соответствии с режимом
	case 1:						//построение графика функции
		ActiveFunc = this;		//сделать объект активным
		WinMain();				//открыть окно для построения графика
		break;
	case 2:						//табулирование функции
		cout << eng("\n\tТабулирование функциии\n")
			<< eng("Исходная функция : y(x) = ") << fName << endl;
		OriginA = A;			//запомнить исходное значение A
		OriginB = B;			//запомнить исходное значение B
		SetAB(param1, param2);	//установить новый отрезок
		cout << eng("Отрезок для табулирования")
			<< ": [" << A << "; " << B << "]\n"
			<< eng("Количество интервалов N = ") << (int)param3 << endl;
		Tabulation((int)param3);		//выполнить табулирование функции
		SetAB(OriginA, OriginB);//венуться к исходному отрезку
		break;
	case 3:						//поиск локальных экстремумов на отрезке
		cout << eng("\n\tЛокальные экстремумы функции на отрезке\n")
			<< eng("Исходная функция: y(x) = ") << fName << endl;
		OriginA = A;			//запомнить исходное значение A
		OriginB = B;			//запомнить исходное значение B
		SetAB(param1, param2);	//установить новый отрезок
		cout << eng("Отрезок для поиска экстремумов")
			<< ": [" << A << "; " << B << "]\n";
		x = MIN();				//найти точку миниимума функции
		y = CountY(x);			//найти минимальное значение функции
		cout << eng("Локальный минимум") 
			<< ": (" << x << "; " << y << ")\n";
		x = MAX();				//найти точку максимума функции
		y = CountY(x);			//найти максимальное значение функции
		cout << eng("Локальный максимум") 
			<< ": (" << x << "; " << y << ")\n";
		SetAB(OriginA, OriginB);//венуться к исходному отрезку
		break;
	case 4:						//найти значение функции в точке
		cout << eng("\n\tЗначение функции и первой производной в точке")
			<< eng("\nИсходная функция: y(x) = ") << fName << endl
			<< eng("Первая производная функции: y'(x) = ") 
			<< dfName << endl << "\nx = " << param1 << "\ny(x) = " 
			<< CountY(param1) << "\ny'(x) = " << CountdY(param1) << endl;
		break;
	case 5:						//решить уравнение вида f(x) = 0
		cout << eng("\n\tРешение уравнения вида f(x) = 0") << endl
			<< eng("Исходная функция: y(x) = ") << fName;
		x = Equation();
		break;
	}//end switch

}//end Func::Caller()

//табулирование функции
void Func::Tabulation(
	int N) {					//количество интервалов
	double x = A;				//аргумент
	double step;				//приращение аргумента
	int iterations = 0;			//счетчик итераций

	//печать шапки таблицы
	cout << char(201);
	for (int i = 0; i < 3; i++) {
		cout << char(205);
	}//end for i
	for (int j = 0; j < 3; j++) {
		cout << char(203);
		for (int i = 0; i < 10; i++) {
			cout << char(205);
		}//end for i
	}//end for j
	cout << char(187) << endl << char(186) << " " << char(252) << " ";
	cout << char(186) << "     x    "
		 << char(186) << "   f(x)   "
		 << char(186) << "   f'(x)  " << char(186) << endl;

	//расчёт шага
	step = N == 1 ? 0 : (B - A) / (N);

	//вход в цикл для печати значений в таблице
	for (int i = 0; i <= N; i++)	{
		cout << char(204);
		for (int k = 0; k < 3; k++) {
			cout << char(205);
		}//end for k
		for (int j = 0; j < 3; j++) {
			cout << char(206);
			for (int k = 0; k < 10; k++) {
				cout << char(205);
			}//end for k
		}//end for j
		cout << char(185) << endl << char(186) 
			 << setw(3) << iterations
			 << char(186) << setw(10) 
			 << fixed << setprecision(6) << x
			 << char(186) << setw(10) 
			 << fixed << setprecision(6) << CountY(x)
			 << char(186) << setw(10) 
			 << fixed << setprecision(6) << CountdY(x)
			 << char(186) << endl;
		iterations += 1;		//увеличение счетчика итераций
		x += step;				//увеличение аргумента
	}//end for i

	// печать нижней границы таблицы
	cout << char(200);
	for (int i = 0; i < 3; i++) {
		cout << char(205);
	}//end for i
	for (int j = 0; j < 3; j++) {
		cout << char(202);
		for (int i = 0; i < 10; i++) {
			cout << char(205);
		}//end for i
	}//end for j
	cout << char(188) << endl;

}//end Func::Tabulation()

//построение графика функции
void Func::Graphic(
	HDC hdc) {					//контекст устройства
	HPEN function =				//перо для построения графика функции
		CreatePen(PS_SOLID, 3, RGB(GC.Red, GC.Green, GC.Blue));
	HPEN derivate =				//перо для построения графика производной
		CreatePen(PS_SOLID, 2, RGB(128, 128, 128));
	HPEN axes =					//перо для построения осей координат
		CreatePen(PS_SOLID, 2, RGB(0, 0, 0));
	HPEN notch =				//перо для построения рисок на осях
		CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
	Point xy = {};				//координаты точки
	string msg;					//текст для вывода в окно
	double step;				//шаг для построения графика

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Для корректного построения графика вводятся две СК:                |
	| 	   логическая                                                    |
	| 	   графическая                                                   |
	| Графическая СК масштабируется относительно логической и измеряет   |
	| расстояние  в пикселях экрана. В каждой СК выбрана область для     |
	| построения графика, в логической СК область графика ограничена точ-|
	| ками dots[0] (левый верхний угол) и dots[1] (правый нижний угол),  |
	| в графической СК - точками dots[2] (левый нижний угол) и dots[3]   |
	| (правый верхний угол). Положение графика на экране задается с по-  |
	| мощью констант Y0 и X0, а ширина и высота рассчитываются исходя из |
	| отношения ширины и высоты области графика в логической СК. Ширина  |
	| области в логической СК соответствует длине отрезка, являющегося   |
	| полем класса, а высота - расстояние между min и max функции на этом|
	| отрезке. При этом размер графика на экране по каждой стороне не    |
	| превышает константного значения, равного 2 * GRAPHSIZE.            |
	\*------------------------------------------------------------------*/

	//инициализация граничных точек графика
	Point* dots = new Point[4];

	//границы области в логической СК
	//левая верхняя точка
	dots[0].X = A;				//координата X
	dots[0].Y = CountY(MAX());	//координата Y
	//правая нижняя точка
	dots[1].X = B;				//координата X
	dots[1].Y = CountY(MIN());	//координата Y

	//границы области в графической СК
	//левая нижняя точка
	dots[2].X = X0;				//координата X
	//правая верхняя точка
	dots[3].Y = Y0;				//координата Y

	//расчет размера области в гафической СК
	if (dots[1].X - dots[0].X	//высота области больше ширины
		< dots[0].Y - dots[1].Y) {
		//задать высоту области максимальной,
		//относительно нее рассчитать ширину
		dots[2].Y = dots[3].Y + 2 * GRAPHSIZE;
		dots[3].X = dots[2].X + 2 * GRAPHSIZE *
					((dots[1].X - dots[0].X)
					/ (dots[0].Y - dots[1].Y));
	} else {					//ширина области больше высоты
		//задать ширину области максимальной,
		//относительно нее рассчитать высоту
		dots[3].X = dots[2].X + 2 * GRAPHSIZE;
		dots[2].Y = dots[3].Y + 2 * GRAPHSIZE *
					((dots[0].Y - dots[1].Y)
					/ (dots[1].X - dots[0].X));
	}//end if

	SelectObject(hdc, axes);	//выбор пера для построения осей
	//построение рамки графика
	Rectangle(hdc, (int)dots[2].X - MARGIN, (int)dots[3].Y - MARGIN,
			 (int)dots[3].X + MARGIN, (int)dots[2].Y + MARGIN);

	//построение осей графика
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			//переход в точку (0;0) в графической СК
			xy.X = scale(0, 0, dots);
			xy.Y = scale(1, 0, dots);
			Move(hdc, xy);		//переход в точку

			//построение полуосей графика с отступами
			switch (j) {
			case 0:				//полуось X
				//предотвращение выхода графика за область построения
				xy.X = EPSround(xy.X) > dots[3].X ? dots[3].X : xy.X;
				xy.X = EPSround(xy.X) < dots[2].X ? dots[2].X : xy.X;
				Move(hdc, xy);	//переход в точку

				//перейти к координате конца полуоси
				xy.X = scale(0, dots[i].X, dots);

				//добавить отступ
				xy.X += (i == 1 ? 1 : -1) * MARGIN;
				break;
			case 1:				//полуось Y
				//предотвращение выхода графика за область построения
				xy.Y = EPSround(xy.Y) < dots[3].Y ? dots[3].Y : xy.Y;
				xy.Y = EPSround(xy.Y) > dots[2].Y ? dots[2].Y : xy.Y;
				Move(hdc, xy);	//переход в точку

				//перейти к координате конца полуоси
				xy.Y = scale(1, dots[i].Y, dots);

				//добавить отступ
				xy.Y += (i == 1 ? 1 : -1) * MARGIN;

				break;
			}//end switch
			Line(hdc, xy);		//построить полуось
		}//end for j
	}//end for i

	//построение рисок на осях графика
	SelectObject(hdc, notch);	//выбор пера для построение рисок на осях
	//ось X
	for (int i = (int)dots[0].X; i <= (int)dots[1].X; i++) {
		if (i == 0) {			//пропустить риску, соответствующую х = 0
			continue;
		}//end if

		//построить риску
		xy.X = scale(0, i, dots);
		xy.Y = scale(1, 0, dots) - 5;
		Move(hdc, xy);			//переход в точку
		xy.Y = scale(1, 0, dots) + 5;
		Line(hdc, xy);			//провести линию между точками

		//подписать значение отрезка
		msg = to_string(i);
		TextOutA(hdc, (int)xy.X - 5, (int)xy.Y + 10,
				 msg.c_str(), (int)msg.length());
	}//end for i
	
	//ось Y
	for (int i = (int)dots[1].Y; i <= (int)dots[0].Y; i++) {
		//построить риску
		xy.Y = scale(1, i, dots);
		xy.X = scale(0, 0, dots) + 5;
		Move(hdc, xy);			//переход в точку
		xy.X = scale(0, 0, dots) - 5;
		Line(hdc, xy);			//провести линию между точками

		//подписать значение отрезка
		msg = to_string(i);
		TextOutA(hdc, (int)xy.X - 20, (int)xy.Y - 5,
				 msg.c_str(), (int)msg.length());
	}//end for i

	//расчет шага для построения графиков
	step = (dots[1].X - dots[0].X) / 100;

	//построение графика производной функции
	SelectObject(hdc, derivate);//выбор пера для построения производной
	//перевод координат левой границы отрезка в графическую СК
	xy.X = scale(0, dots[0].X, dots);
	xy.Y = scale(1, CountdY(dots[0].X), dots);
	//предотвращение выхода графика за область построения
	xy.Y = EPSround(xy.Y) < dots[3].Y ? dots[3].Y : xy.Y;
	xy.Y = EPSround(xy.Y) > dots[2].Y ? dots[2].Y : xy.Y;
	Move(hdc, xy);			//переход в точку

	//цикл до правой границы отрезка с заданным шагом step
	for (double i = dots[0].X + step; i <= dots[1].X + EPS; i += step) {
		//расчет координат новой точки в графической СК
		xy.X = scale(0, i, dots);
		xy.Y = scale(1, CountdY(i), dots);

		//предотвращение выхода графика за область построения
		((EPSround(xy.Y) < dots[3].Y) || (EPSround(xy.Y) > dots[2].Y)) ?
			Move(hdc, xy) : //переход в точку
			Line(hdc, xy);	//провести линию между точками
	}//end for i

	//построение графика функции
	SelectObject(hdc, function);//выбор пера для построения функции
	//перевод координат левой границы отрезка в графическую СК
	xy.X = scale(0, dots[0].X, dots);
	xy.Y = scale(1, CountY(dots[0].X), dots);
	Move(hdc, xy);				//переход в точку

	//цикл до правой границы отрезка с заданным шагом step
	for (double i = dots[0].X + step; i <= dots[1].X + EPS; i += step) {
		//расчет координат новой точки в графической СК
		xy.X = scale(0, i, dots);
		xy.Y = scale(1, CountY(i), dots);

		Line(hdc, xy);			//провести линию между точками
	}//end for i

	//печать заголовка
	msg = "\tПостроение графика функции и ее первой производной";
	TextOutA(hdc, 5, 0, msg.c_str(), (int)msg.length());
	msg = "Исходная функция: y(x) = "
		+ ActiveFunc->GetfName() + " (" + ActiveFunc->GetColName()
		+ " график)";
	TextOutA(hdc, 5, 15, msg.c_str(), (int)msg.length());
	msg = "Первая производная функции: y'(x) = "
		+ ActiveFunc->GetfName() + " (серый график)";
	TextOutA(hdc, 5, 30, msg.c_str(), (int)msg.length());

	//овобождение памяти
	DeleteObject(function);
	DeleteObject(derivate);
	DeleteObject(axes);
	DeleteObject(notch);

}//end Func::Graphic()

//поиск корня уравнения f(x) = 0 методом половинного деления
double Func::dihotom(
	int mode) {					//режим расчета функции
	double a = A;				//нижняя граница отрезка
	double b = B;				//верхняя граница отрезка
	double c = (b + a) / 2;		//середина отрезка
	int i = 0;					//счетчик итераций

	//корень не на отрезке [a;b]
	if (func(mode, a) * func(mode, b) > 0) {	
		return INFINITY;
	}//end if

	//итерационный поиск корня уравнения
	while ((b - a) / 2 > EPS) {	//пока длина отрезка больше точности
		//корень уравнения - одна из точек a, b или c
		if (func(mode, a) * func(mode, b) * func(mode, c) == 0) {
			return (func(mode, a) == 0 ? a : 
				   (func(mode, b) == 0 ? b : 
				   (func(mode, c) == 0 ? c : 0)));
		//корень на отрезке [a;c]
		} else if (func(mode, a) * func(mode, c) < 0) {
			b = c;
		//корень на отрезке [c;b]
		} else if (func(mode, b) * func(mode, c) < 0) {
			a = c;						
		}//end if

		c = (b + a) / 2;		//расчет середины отрезка
		i++;					//увеличение счетчика итераций
	}//end while

	return c;					//вернуть корень уравнения

}//end Func::dihotom()

//проверка, является ли точка точкой максимума
bool Func::isMax(
	double x) {					//аргумент функции для проверки
	
	//вернуть результат проверки условий, что х 
	//не равен бесконечности, левее х функция возрастает,
	//а правее х функция убывает, предполагаемый максимум
	//больше значений функции в граничных точках отрезка
	return ((x != INFINITY)
		&& ((CountdY(x - EPS) > 0) && (CountdY(x + EPS) < 0))
		&& (CountY(x) >= CountY(A)) && (CountY(x) >= CountY(B)));

}//end Func::isMax()

//проверка, является ли точка точкой минимума
bool Func::isMin(
	double x) {					//аргумент функции для проверки

	//вернуть результат проверки условий, что х 
	//не равен бесконечности, левее х функция убывает,
	//а правее х функция возрастает, предполагаемый минимум
	//меньше  значений функции в граничных точках отрезка
	return ((x != INFINITY)
		&& ((CountdY(x - EPS) < 0) && (CountdY(x + EPS) > 0))
		&& (CountY(x) <= CountY(A)) && (CountY(x) <= CountY(B)));

}//end Func::isMin()

//вызов f(x) или f'(x), с округлением или без
double Func::func(
	int mode,					//режим работы
	double x) {					//аргумент функции

	switch (mode) {				//выбор метода в соответствии с режимом
	case -1:					//исходная функция с округлением
		return EPSround(CountY(x));
	case 1:						//исходная функция без округления
		return CountY(x);
	case -2:					//производная функции с округлением
		return EPSround(CountdY(x));
	case 2:						//производная функции без округления
		return CountY(x);
	default:
		return 0.0;
	}//end switch

}//end Func::func()

//обработка результата работы dihotom()
double Func::Equation(void) {
	double x;					//корень уравнения

	x = dihotom(1);				//поиск корня методом половинного деления

	if (x != INFINITY) {		//корень найден
		cout << "\tx = " << x << endl;
	} else {					//корень не найден
		cout << eng("Решение не найдено на отрезке")
			<< " [" << A << "; " << B << "].\n";
	}//end if

	return x;					//вернуть корень уравнения

}//end Func::Equation()

//поиск точки локального max на отрезке
double Func::MAX(void) {
	double X;					//локальная точка максимума

	//поиск х, при котором f'(x) = 0
	X = dihotom(2);

	if (isMax(X)) {				//найденный х - это точка максимума
		return X;				//вернуть результат
	} else {					//точка максимума не найдена
		//вернуть границу отрезка с наибольшим значенем функции
		return CountY(A) >= CountY(B) ? A : B;
	}//end if

}//end Func::MAX()

//поиск точки локального min на отрезке
double Func::MIN(void) {
	double X;					//локальная точка минимума

	//поиск х, при котором f'(x) = 0
	X = dihotom(2);
	if (isMin(X)) {				//найденный х - это точка минимума
		return X;				//вернуть результат
	} else {					//точка минимума не найдена
		//вернуть границу отрезка с наименьшим значенем функции
		return CountY(A) <= CountY(B) ? A : B;
	}//end if

}//end Func::MIN()

//расчет значения функции в точке X
double Func::CountY(
	double x) {						//аргумент функции

	return (1.2 * x - 3);			//вернуть значение функции

}//end Func::CountY()

//расчет значения производной функции в точке X
double Func::CountdY(
	double x) {					//аргумент функции

	return (1.2);				//вернуть значение производной

}//end Func::CountdY()

/*---------------------------------------*\
|          Методы класса ExpFunc          |
\*---------------------------------------*/
//конструктор
ExpFunc::ExpFunc(
	double InitA,				//левая граница отрезка
	double InitB)				//правая граница отрезка
	: Func(InitA, InitB) {

	//инициализация закрытых полей класса
	fName = "e ^ x";			//формула функции
	dfName = "e ^ x";			//формул производной функции
	colName = "красный";		//название цвета графика функции
	GC = { 191, 8, 8 };			//цвет графика функции

}//end ExpFunc::ExpFunc()

//обработка результата работы dihotom()
double ExpFunc::Equation(void){
	//печать решения уравнения
	cout << "\tx = " << -INFINITY << endl;

	return -INFINITY;			//вернуть результат

}//ExpFunc::Equation()

//расчет значения функции в точке X
double ExpFunc::CountY(
	double x) {					//аргумент функции

	return (exp(x));			//вернуть значение функции

}//end ExpFunc::CountY()

//расчет значения производной функции в точке X
double ExpFunc::CountdY(
	double x) {					//аргумент функции

	return (exp(x));			//вернуть значение производной

}//end ExpFunc::CountdY()

/*---------------------------------------*\
|          Методы класса SinFunc          |
\*---------------------------------------*/
//конструктор
SinFunc::SinFunc(
	double InitA,				//левая граница отрезка
	double InitB)				//правая граница отрезка
	: Func(InitA, InitB) {

	//инициализация закрытых полей класса
	fName = "sin(x)";			//формула функции
	dfName = "cos(x)";			//формул производной функции
	colName = "салатовый";		//название цвета графика функции
	GC = { 17, 242, 55 };		//цвет графика функции

}//end SinFunc::SinFunc()

//обработка результата работы dihotom()
double SinFunc::Equation(void) {
	double X1, X2;				//корни уравнения
	double OriginA = A;			//исходная левая граница отрезка
	double OriginB = B;			//исходная правая граница отрезка

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| На отрезке может быть несколько корней уравнения, поэтому для поис-|
	| ка корня численными методами требуется сначала отделить возможные  |
	| корни друг от друга. Также значения функции sin(x) повторяются на  |
	| каждом отрезке, равном 2 * pi. Из этих соображений, если длина     |
	| отрезка [A; B] > 2 * pi, достаточно найти корень уравнения на одном|
	| из отрезков [A; A + pi] и [A + pi; A + 2 * pi]. Если длина отрезка |
	| pi < [A; B] < 2 * pi, корень уравнения нужно последовательно искать|
	| на отрезках [A; A + pi] и [B - pi; B]. Второй отрезок отсчитывается|
	| отночительно В, чтобы не искать корень уравнения вне исходного     |
	| отрезка. Если длина отрезка [A; B] < pi, менять отрезок не нужно,  |
	| численные методы будут работать корректно.                         |
	\*------------------------------------------------------------------*/

	//рассмотрение первого отрезка
	if (B - A > M_PI) {			//длина отрезка > pi
		//переход к отрезку [A; A + pi]
		B = A + M_PI;			
	}//end if

	X1 = dihotom(-1);			//поиск корня методом половинного деления
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	if (X1 != INFINITY) {		//корень найден на первом отрезке
		cout << "\tx = " << X1 << endl;
		return X1;				//вернуть корень уравнения
	}//end if

	//рассмотрение второго отрезка
	if (B - A > M_PI * 2) {		//длина отрезка > 2 * pi
		//переход к отрезку [A + pi; A + 2 * pi]
		A += M_PI;
		B = A + M_PI;
	} else if (B - A > M_PI) {	//длина отрезка > pi и  < 2 * pi
		//переход к отрезку [B - pi; B]
		A = B - M_PI;
	}//end if

	X2 = dihotom(-1);			//поиск корня методом половинного деления
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	if (X2 != INFINITY) {		//корень найден на втором отрезке
		cout << "\tx = " << X2 << endl;
	} else {					//корень не найден
		cout << eng("Решение не найдено на отрезке");
	}//end if

	return X2;					//вернуть корень уравнения

}//end SinFunc::Equation()

//поиск локального max на отрезке
double SinFunc::MAX(void) {
	double X1, X2;				//локальные точки максимума
	bool max1, max2;			//результаты проверок точек максимума
	double OriginA = A;			//исходная левая граница отрезка
	double OriginB = B;			//исходная правая граница отрезка

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Для поиска локального максимума на отрезке найдем точку, в которой |
	| первая производная функции равна 0, левее этой точки > 0, а правее |
	| < 0. Корме того требуется проверить, превышает ли значение функции |
	| в предполагаемой точке максимума значения функции в граничных точ- |
	| ках отрезка. Для этого решим уравнение вида f'(x) = 0 одним из чис-|
	| ленных методов. На отрезке может быть несколько корней уравнения,  |
	| поэтому для поиска корня требуется сначала отделить возможные корни|
	| друг от друга. Также значения производной функции cos(x) повторяют-|
	| ся на каждом отрезке, равном 2 * pi. Из этих соображений, если     |
	| длина отрезка [A; B] > 2 * pi, достаточно найти корени уравнения   |
	| на отрезках [A; A + pi] и [A + pi; A + 2 * pi]. Если длина отрезка |
	| pi < [A; B] < 2 * pi, корни уравнения нужно искать на отрезках     |
	| [A; A + pi] и [B - pi; B]. Второй отрезок отсчитывается отноcитель-|
	| но В, чтобы не искать корни уравнения вне исходного отрезка. Если  |
	| длина отрезка [A; B] < pi, менять отрезок не нужно, численные мето-|
	| ды будут работать корректно. После того, как корни на всех рас-    |
	| сматриваемых отрезках найдены, нужно сравнить значения в найденных |
	| точках и граничных точках отрезка. В искомой точке значение функции|
	| будет наибольшим.                                                  |
	\*------------------------------------------------------------------*/

	//рассмотрение первого отрезка
	if (B - A > M_PI) {			//длина отрезка > pi
		//переход к отрезку [A; A + pi]
		B = A + M_PI;
	}//end if

	X1 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	max1 = isMax(X1);			//проверка, есть ли максимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//рассмотрение второго отрезка
	if (B - A > M_PI * 2) {		//длина отрезка > 2 * pi
		//переход к отрезку [A + pi; A + 2 * pi]
		A += M_PI;
		B = A + M_PI;
	} else if (B - A > M_PI) {	//длина отрезка > pi и  < 2 * pi
		//переход к отрезку [B - pi; B]
		A = B - M_PI;
	}//end if

	X2 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	max2 = isMax(X2);			//проверка, есть ли максимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//сравнение найденных точек
	if (max1) {					//найденный X1 - это точка максимума
		if (max2) {				//найденный X2 - это точка максимума
			//вернуть результат с наибольшим значением функции
			return CountY(X2) > CountY(X1) ? X2 : X1;
		} else {				//в точке Х2 максимум не найден
			return X1;			//вернуть результат X1
		}//end if
	} else if (max2) {			//найденный X2 - это точка максимума
		if (max1) {				//найденный X1 - это точка максимума
			//вернуть результат с наибольшим значением функции
			return CountY(X1) > CountY(X2) ? X1 : X2;
		} else {				//в точке Х1 максимум не найден
			return X2;			//вернуть результат X2
		}//end if
	} else {					//точка максимума не найдена
		//вернуть границу отрезка с наибольшим значенем функции
		return CountY(A) >= CountY(B) ? A : B;
	}//end if

}//end SinFunc::MAX()

//поиск локального min на отрезке
double SinFunc::MIN(void) {
	double X1, X2;				//локальные точки минимума
	bool min1, min2;			//результаты проверок точек минимума
	double OriginA = A;			//исходная левая граница отрезка
	double OriginB = B;			//исходная правая граница отрезка

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Для поиска локального минимума на отрезке найдем точку, в которой  |
	| первая производная функции равна 0, левее этой точки < 0, а правее |
	| > 0. Корме того требуется проверить, меньше ли значение функции в  |
	| предполагаемой точке минимума, чем значения функции в граничных    |
	| точках отрезка. Для этого решим уравнение вида f'(x) = 0 одним из  |
	| численных методов. На отрезке может быть несколько корней уравне-  |
	| ния, поэтому для поиска корня требуется сначала отделить возможные |
	| корни друг от друга. Также значения производной функции cos(x)     |
	| повторяются на каждом отрезке, равном 2 * pi. Из этих соображений, |
	| еслидлина отрезка [A; B] > 2 * pi, достаточно найти корени уравне- |
	| ния на отрезках [A; A + pi] и [A + pi; A + 2 * pi]. Если длина от- |
	| резка pi < [A; B] < 2 * pi, корни уравнения нужно искать на отрез- |
	| ках [A; A + pi] и [B - pi; B]. Второй отрезок отсчитывается отноcи-|
	| тельно В, чтобы не искать корни уравнения вне исходного отрезка.   |
	| Если длина отрезка [A; B] < pi, менять отрезок не нужно, численные |
	| методы будут работать корректно. После того, как корни на всех     |
	| рассматриваемых отрезках будутнайдены, нужно сравнить значения в   |
	| найденных точках и граничных точках отрезка. В искомой точке       |
	| значение функции будет наименьшим.                                 |
	\*------------------------------------------------------------------*/

	//рассмотрение первого отрезка
	if (B - A > M_PI) {			//длина отрезка > pi
		//переход к отрезку [A; A + pi]
		B = A + M_PI;
	}//end if

	X1 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	min1 = isMin(X1);			//проверка, есть ли минимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//рассмотрение второго отрезка
	if (B - A > M_PI * 2) {		//длина отрезка > 2 * pi
		//переход к отрезку [A + pi; A + 2 * pi]
		A += M_PI;
		B = A + M_PI;
	} else if (B - A > M_PI) {	//длина отрезка > pi и  < 2 * pi
		//переход к отрезку [B - pi; B]
		A = B - M_PI;
	}//end if

	X2 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	min2 = isMin(X2);			//проверка, есть ли минимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//сравнение найденных точек
	if (min1) {					//найденный X1 - это точка минимума
		if (min2) {				//найденный X2 - это точка минимума
			//вернуть результат с наименьшим значением функции
			return X2 < X1 ? X2 : X1;
		} else {				//в точке Х2 минимум не найден
			return X1;			//вернуть результат X1
		}//end if
	} else if (min2) {			//найденный X2 - это точка минимума
		if (min1) {				//найденный X1 - это точка минимума
			//вернуть результат с наименьшим значением функции
			return X1 < X2 ? X1 : X2;
		} else {				//в точке Х1 минимум не найден
			return X2;
		}//end if
	} else {					//точка минимума не найдена
			//вернуть результат с наименьшим значением функции
		return CountY(A) <= CountY(B) ? A : B;
	}//end if

}//end SinFunc::MIN()()

//расчет значения функции в точке X
double SinFunc::CountY(
	double x) {					//аргумент функции
	return (sin(x));			//вернуть значение функции

}//end SinFunc::CountY()

//расчет значения производной функции в точке X
double SinFunc::CountdY(
	double x) {					//аргумент функции
	return (cos(x));			//вернуть значение производной

}//end SinFunc::CountdY()

/*---------------------------------------*\
|          Методы класса CosFunc          |
\*---------------------------------------*/
//конструктор
CosFunc::CosFunc(
	double InitA,				//левая граница отрезка
	double InitB)				//правая граница отрезка
	: Func(InitA, InitB) {

	//инициализация закрытых полей класса
	fName = "cos(x)";			//формула функции
	dfName = "-sin(x)";			//формул производной функции
	colName = "синий";			//название цвета графика функции
	GC = { 21, 3, 138 };		//цвет графика функции

}//end CosFunc::CosFunc()

//обработка результата работы dihotom()
double CosFunc::Equation(void) {
	double X1, X2;				//корни уравнения
	double OriginA = A;			//исходная левая граница отрезка
	double OriginB = B;			//исходная правая граница отрезка

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| На отрезке может быть несколько корней уравнения, поэтому для поис-|
	| ка корня численными методами требуется сначала отделить возможные  |
	| корни друг от друга. Также значения функции sin(x) повторяются на  |
	| каждом отрезке, равном 2 * pi. Из этих соображений, если длина     |
	| отрезка [A; B] > 2 * pi, достаточно найти корень уравнения на одном|
	| из отрезков [A; A + pi] и [A + pi; A + 2 * pi]. Если длина отрезка |
	| pi < [A; B] < 2 * pi, корень уравнения нужно последовательно искать|
	| на отрезках [A; A + pi] и [B - pi; B]. Второй отрезок отсчитывается|
	| отночительно В, чтобы не искать корень уравнения вне исходного     |
	| отрезка. Если длина отрезка [A; B] < pi, менять отрезок не нужно,  |
	| численные методы будут работать корректно.                         |
	\*------------------------------------------------------------------*/

	//рассмотрение первого отрезка
	if (B - A > M_PI) {			//длина отрезка > pi
		//переход к отрезку [A; A + pi]
		B = A + M_PI;			
	}//end if

	X1 = dihotom(-1);			//поиск корня методом половинного деления
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	if (X1 != INFINITY) {		//корень найден на первом отрезке
		cout << "\tx = " << X1 << endl;
		return X1;				//вернуть корень уравнения
	}//end if

	//рассмотрение второго отрезка
	if (B - A > M_PI * 2) {		//длина отрезка > 2 * pi
		//переход к отрезку [A + pi; A + 2 * pi]
		A += M_PI;
		B = A + M_PI;
	} else if (B - A > M_PI) {	//длина отрезка > pi и  < 2 * pi
		//переход к отрезку [B - pi; B]
		A = B - M_PI;
	}//end if

	X2 = dihotom(-1);			//поиск корня методом половинного деления
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	if (X2 != INFINITY) {		//корень найден на втором отрезке
		cout << "\tx = " << X2 << endl;
	} else {					//корень не найден
		cout << eng("Решение не найдено на отрезке");
	}//end if

	return X2;					//вернуть корень уравнения

}//end CosFunc::Equation()

//поиск локального max на отрезке
double CosFunc::MAX(void) {
	double X1, X2;				//локальные точки максимума
	bool max1, max2;			//результаты проверок точек максимума
	double OriginA = A;			//исходная левая граница отрезка
	double OriginB = B;			//исходная правая граница отрезка

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Для поиска локального максимума на отрезке найдем точку, в которой |
	| первая производная функции равна 0, левее этой точки > 0, а правее |
	| < 0. Корме того требуется проверить, превышает ли значение функции |
	| в предполагаемой точке максимума значения функции в граничных точ- |
	| ках отрезка. Для этого решим уравнение вида f'(x) = 0 одним из чис-|
	| ленных методов. На отрезке может быть несколько корней уравнения,  |
	| поэтому для поиска корня требуется сначала отделить возможные корни|
	| друг от друга. Также значения производной функции -sin(x) повторя- |
	| ются на каждом отрезке, равном 2 * pi. Из этих соображений, если   |
	| длина отрезка [A; B] > 2 * pi, достаточно найти корени уравнения   |
	| на отрезках [A; A + pi] и [A + pi; A + 2 * pi]. Если длина отрезка |
	| pi < [A; B] < 2 * pi, корни уравнения нужно искать на отрезках     |
	| [A; A + pi] и [B - pi; B]. Второй отрезок отсчитывается отноcитель-|
	| но В, чтобы не искать корни уравнения вне исходного отрезка. Если  |
	| длина отрезка [A; B] < pi, менять отрезок не нужно, численные мето-|
	| ды будут работать корректно. После того, как корни на всех рас-    |
	| сматриваемых отрезках найдены, нужно сравнить значения в найденных |
	| точках и граничных точках отрезка. В искомой точке значение функции|
	| будет наибольшим.                                                  |
	\*------------------------------------------------------------------*/

	//рассмотрение первого отрезка
	if (B - A > M_PI) {			//длина отрезка > pi
		//переход к отрезку [A; A + pi]
		B = A + M_PI;
	}//end if

	X1 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	max1 = isMax(X1);			//проверка, есть ли максимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//рассмотрение второго отрезка
	if (B - A > M_PI * 2) {		//длина отрезка > 2 * pi
		//переход к отрезку [A + pi; A + 2 * pi]
		A += M_PI;
		B = A + M_PI;
	} else if (B - A > M_PI) {	//длина отрезка > pi и  < 2 * pi
		//переход к отрезку [B - pi; B]
		A = B - M_PI;
	}//end if

	X2 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	max2 = isMax(X2);			//проверка, есть ли максимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//сравнение найденных точек
	if (max1) {					//найденный X1 - это точка максимума
		if (max2) {				//найденный X2 - это точка максимума
			//вернуть результат с наибольшим значением функции
			return CountY(X2) > CountY(X1) ? X2 : X1;
		} else {				//в точке Х2 максимум не найден
			return X1;			//вернуть результат X1
		}//end if
	} else if (max2) {			//найденный X2 - это точка максимума
		if (max1) {				//найденный X1 - это точка максимума
			//вернуть результат с наибольшим значением функции
			return CountY(X1) > CountY(X2) ? X1 : X2;
		} else {				//в точке Х1 максимум не найден
			return X2;			//вернуть результат X2
		}//end if
	} else {					//точка максимума не найдена
		//вернуть границу отрезка с наибольшим значенем функции
		return CountY(A) >= CountY(B) ? A : B;
	}//end if

}//end CosFunc::MAX()

//поиск локального min на отрезке
double CosFunc::MIN(void) {
	double X1, X2;				//локальные точки минимума
	bool min1, min2;			//результаты проверок точек минимума
	double OriginA = A;			//исходная левая граница отрезка
	double OriginB = B;			//исходная правая граница отрезка

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Для поиска локального минимума на отрезке найдем точку, в которой  |
	| первая производная функции равна 0, левее этой точки < 0, а правее |
	| > 0. Корме того требуется проверить, меньше ли значение функции в  |
	| предполагаемой точке минимума, чем значения функции в граничных    |
	| точках отрезка. Для этого решим уравнение вида f'(x) = 0 одним из  |
	| численных методов. На отрезке может быть несколько корней уравне-  |
	| ния, поэтому для поиска корня требуется сначала отделить возможные |
	| корни друг от друга. Также значения производной функции -sin(x)    |
	| повторяются на каждом отрезке, равном 2 * pi. Из этих соображений, |
	| еслидлина отрезка [A; B] > 2 * pi, достаточно найти корени уравне- |
	| ния на отрезках [A; A + pi] и [A + pi; A + 2 * pi]. Если длина от- |
	| резка pi < [A; B] < 2 * pi, корни уравнения нужно искать на отрез- |
	| ках [A; A + pi] и [B - pi; B]. Второй отрезок отсчитывается отноcи-|
	| тельно В, чтобы не искать корни уравнения вне исходного отрезка.   |
	| Если длина отрезка [A; B] < pi, менять отрезок не нужно, численные |
	| методы будут работать корректно. После того, как корни на всех     |
	| рассматриваемых отрезках будутнайдены, нужно сравнить значения в   |
	| найденных точках и граничных точках отрезка. В искомой точке       |
	| значение функции будет наименьшим.                                 |
	\*------------------------------------------------------------------*/

	//рассмотрение первого отрезка
	if (B - A > M_PI) {			//длина отрезка > pi
		//переход к отрезку [A; A + pi]
		B = A + M_PI;
	}//end if

	X1 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	min1 = isMin(X1);			//проверка, есть ли минимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//рассмотрение второго отрезка
	if (B - A > M_PI * 2) {		//длина отрезка > 2 * pi
		//переход к отрезку [A + pi; A + 2 * pi]
		A += M_PI;
		B = A + M_PI;
	} else if (B - A > M_PI) {	//длина отрезка > pi и  < 2 * pi
		//переход к отрезку [B - pi; B]
		A = B - M_PI;
	}//end if

	X2 = dihotom(-2);			//поиск х, при котором f'(x) = 0
	min2 = isMin(X2);			//проверка, есть ли минимум в точке
	//возвращение к исходному отрезку
	A = OriginA;
	B = OriginB;

	//сравнение найденных точек
	if (min1) {					//найденный X1 - это точка минимума
		if (min2) {				//найденный X2 - это точка минимума
			//вернуть результат с наименьшим значением функции
			return X2 < X1 ? X2 : X1;
		} else {				//в точке Х2 минимум не найден
			return X1;			//вернуть результат X1
		}//end if
	} else if (min2) {			//найденный X2 - это точка минимума
		if (min1) {				//найденный X1 - это точка минимума
			//вернуть результат с наименьшим значением функции
			return X1 < X2 ? X1 : X2;
		} else {				//в точке Х1 минимум не найден
			return X2;
		}//end if
	} else {					//точка минимума не найдена
			//вернуть результат с наименьшим значением функции
		return CountY(A) <= CountY(B) ? A : B;
	}//end if

}//end CosFunc::MIN()()

//расчет значения функции в точке X
double CosFunc::CountY(
	double x) {					//аргумент функции

	return (cos(x));			//вернуть значение функции

}//end CosFunc::CountY()

//расчет значения производной функции в точке X
double CosFunc::CountdY(
	double x) {					//аргумент функции

	return (-sin(x));			//вернуть значение производной

}//end CosFunc::CountdY()

/*-----------------------------------------*\
|          Методы класса ParabFunc          |
\*-----------------------------------------*/
//конструктор
ParabFunc::ParabFunc(
	double InitA,				//левая граница отрезка
	double InitB)				//правая граница отрезка
	: Func(InitA, InitB) {

	//инициализация закрытых полей класса
	fName = "x ^ 2";			//формула функции
	dfName = "2 * x";			//формул производной функции
	colName = "желтый";			//название цвета графика функции
	GC = { 255, 238, 0 };		//цвет графика функции

}//end ParabFunc::ParabFunc()

//обработка результата работы dihotom()
double ParabFunc::Equation(void) {
	double topX;				//вершина параболы
	double X;					//корень уравнения
	double OriginB = B;			//исходная правая граница отрезка

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Парабола может касаться оси Х или пересекать ее дважды, в обоих    |
	| случаях численные методы поиска корня не будут работать. Если отре-|
	| зок поиска уравнения содержит вершину параболы, достаточно рассмот-|
	| реть только отрезок [A; <Х вершиины>]. При этом, если корень урав- |
	| нения не является вершиной параболы, то существует второй корень,  |
	| равный -1 * <корень №1>. Если отрезок не содержит вершину параболы,|
	| менять его не нужно, численные методы будут работать корректно.    |
	\*------------------------------------------------------------------*/

	//расчет Х-координаты вершины параболы
	topX = -1 * (CountdY(0) / (CountdY(1) - CountdY(0)));
	topX = topX == -0 ? 0 : topX;

	//проверка отрезка на содержание вершины параболы
	if ((A < topX) && (topX < B)) {
		B = topX;				//установка нового отрезка
	}//end if

	X = dihotom(1);				//поиск корня методом половинного деления
	B = OriginB;				//возвращение к исходному отрезку
	
	if (X != INFINITY) {		//корень найден
		cout << "\tx = " << X;
		if (X != topX) {		//корень не вешина параболы
			cout << ";\t" << -X;//печать второго корня
		}//end if
		cout << endl;
	} else {					//корень не найден
		cout << eng("Решение не найдено на отрезке");
	}//ebd if

	return X;					//вернуть корень уравнения

}//end ParabFunc::Equation()

//поиск локального max на отрезке
double ParabFunc::MAX(void) {
	double topX;				//вершина параболы

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Парабола не ограничена сверху, если коэффициент при х^2 > 0, тогда |
	| максимумом будет наибольшее значение функции в граничных точках от-|
	| резка. Если же коэффициент при х^2 < 0, точкой максимума будет вер-|
	| шина параболы. Для поиска максимума проверим, находится ли вершина |
	| параболы в отрезке, если да, проверим, является ли она точкой мак- |
	| симумом. Для этого первая производная функции в точке должна быть  |
	| равна 0, левее этой точки > 0, а правее < 0. Корме того требуется  |
	| проверить, превышает ли значение функции в предполагаемой точке    |
	| максимума значения функции в граничных точках отрезка. Если        |
	| точка максимума не найдена, это одна из граничных точек с          |
	| наибольшим значением функции.                                      |
	\*------------------------------------------------------------------*/

	//расчет Х-координаты вершины параболы
	topX = -1 * (CountdY(0) / (CountdY(1) - CountdY(0)));
	topX = topX == -0 ? 0 : topX;

	//проверка отрезка на содержание вершины параболы
	if ((A < topX) && (topX < B)) {
		if (isMax(topX)) {		//вершина параболы - точка максимума
			return topX;		//вернуть точку максимума на отрезке
		}//end if
	}//end if

	//вернуть граничную точку отрезка с наибольшим значением функции
	return CountY(A) >= CountY(B) ? A : B;

}//end ParabFunc::MAX()

//поиск локального min на отрезке
double ParabFunc::MIN(void) {
	double topX;				//вершина параболы

	/*--------------------------- ПРИМЕЧАНИЕ ---------------------------*\
	| Парабола не ограничена снизу, если коэффициент при х^2 < 0, тогда  |
	| минимумом будет наименьшее значение функции в граничных точках от- |
	| резка. Если же коэффициент при х^2 > 0, точкой минимума будет вер- |
	| шина параболы. Для поиска минимума проверим, находится ли вершина  |
	| параболы в отрезке, если да, проверим, является ли она точкой мини-|
	| мума. Для этого первая производная функции в точке должна быть рав-|
	| на 0, левее этой точки < 0, а правее > 0. Корме того требуется     |
	| проверить, меньше ли значение функции в предполагаемой точке мини- |
	| мума, чем значения функции в граничных точках отрезка. Если точка  |
	| минимума не найдена, это одна из граничных точек с наименьшим      |
	| значением функции.                                                 |
	\*------------------------------------------------------------------*/

	//расчет Х-координаты вершины параболы
	topX = -1 * (CountdY(0) / (CountdY(1) - CountdY(0)));
	topX = topX == -0 ? 0 : topX;

	//проверка отрезка на содержание вершины параболы
	if ((A < topX) && (topX < B)) {
		if (isMin(topX)) {		//вершина параболы - точка минимума
			return topX;		//вернуть точку минимума на отрезке
		}//end if
	}//end if

	//вернуть граничную точку отрезка с наименьшим значением функции
	return CountY(A) <= CountY(B) ? A : B;

}//end ParabFunc::MIN()

//расчет значения функции в точке X
double ParabFunc::CountY(
	double x) {					//аргумент функции

	return (pow(x, 2));			//вернуть значение функции

}//end ParabFunc::CountY()

//расчет значения производной функции в точке X
double ParabFunc::CountdY(
	double x) {					//аргумент функции

	return (2 * x);				//вернуть значение производной

}//end ParabFunc::CountdY()

/*---------------------------------------*\
|          Методы класса LogFunc          |
\*---------------------------------------*/
//конструктор
LogFunc::LogFunc(
	double InitA,				//левая граница отрезка
	double InitB)				//правая граница отрезка
	: Func(InitA > 0 ? InitA : EPS, InitB) {

	//инициализация закрытых полей класса
	fName = "ln(x)";			//формула функции
	dfName = "1 / x";			//формул производной функции
	colName = "фиолетовый";		//название цвета графика функции
	GC = { 113, 4, 176 };		//цвет графика функции

}//end LogFunc::LogFunc()

//расчет значения функции в точке X
double LogFunc::CountY(
	double x) {					//аргумент функции

	return (log(x));			//вернуть значение функции

}//end LogFunc::CountY()

//расчет значения производной функции в точке X
double LogFunc::CountdY(
	double x) {					//аргумент функции

	return (1 / x);				//вернуть значение производной

}//end LogFunc::CountdY()

/*----------------------------------------*\
|          Методы класса SqrtFunc          |
\*----------------------------------------*/
//конструктор
SqrtFunc::SqrtFunc(
	double InitA,				//левая граница отрезка
	double InitB)				//правая граница отрезка
	: Func(InitA < 0 ? 0 : InitA, InitB) {

	//инициализация закрытых полей класса
	fName = "sqrt(x)";			//формула функции
	dfName = "1 / (2 * sqrt(x))";//формул производной функции
	colName = "голубой";		//название цвета графика функции
	GC = { 0, 200, 255 };		//цвет графика функции

}//end SqrtFunc::SqrtFunc()

//расчет значения функции в точке X
double SqrtFunc::CountY(
	double x) {					//аргумент функции

	return (sqrt(x));			//вернуть значение функции

}//end SqrtFunc::CountY()

//расчет значения производной функции в точке X
double SqrtFunc::CountdY(
	double x) {					//аргумент функции

	return (1 / (2 * sqrt(x)));	//вернуть значение производной

}//end SqrtFunc::CountdY()

/************************************************************************\
|*                 Р Е А Л И З А Ц И Я   Ф У Н К Ц И Й                  *|
\************************************************************************/
/*----------------------------------------------------------------*\
|   Переместить перо из текущего положения пера в заданную точку   |
\*----------------------------------------------------------------*/
void Move(
	HDC hdc,					//контекст устройства
	Point point) {				//конечная точка

	//переместить активное перо из текущего положения в конечную точку
	MoveToEx(hdc, (int)point.X, (int)point.Y, NULL);

}//end Move()

/*---------------------------------------------------------------*\
|   Провести линию из текущего положения пера до заданной точки   |
\*---------------------------------------------------------------*/
void Line(
	HDC hdc,					//контекст устройства
	Point point) {				//конечная точка

	//провести линию из текущего положения до конечной точки
	LineTo(hdc, (int)point.X, (int)point.Y);

}//end Line()

/*---------------------------------------------------*\
|   Масштабирование значений для построения графика   |
\*---------------------------------------------------*/
double scale(
	int mode,
	double arg,					//значение аргумента
	Point* dots) {				//коэффициенты масштабирования
	double* koeffs = new double[4];

	if (mode == 0) {
		for (int i = 0; i < 4; i++) {
			koeffs[i] = dots[i].X;
		}
	} else {
		for (int i = 0; i < 4; i++) {
			koeffs[i] = dots[i].Y;
		}
	}
	return mode ==0?(((arg - koeffs[0]) / (koeffs[1] - koeffs[0]))
			* (koeffs[3] - koeffs[2])) + koeffs[2]:
		(((arg - koeffs[1]) / (koeffs[0] - koeffs[1]))
			* (koeffs[3] - koeffs[2])) + koeffs[2];
}//end scale()

/*-----------------------------------------*\
|   Перевод строки в английскую кодировку   |
\*-----------------------------------------*/
string eng(
	string rus) {					//строка в русской кодировке
	string eng = rus;				//строка в английской кодировке
	int i;							//счетчик

	//перевод строки из русской кодировки в английскую
	for (i = 0; i < size(rus); i++) {
		//смещение кода для символов от "А" до "п"
		if ((-65 < int(rus[i])) && (int(rus[i]) < -16)) {
			eng[i] = rus[i] - 64;
			continue;
		}//end if

		//смещение кода для символов от "р" до "я"
		if ((-17 < int(rus[i])) && (int(rus[i]) < 0)) {
			eng[i] = rus[i] - 16;
			continue;
		}//end if
	}//end for i

	return eng;						//вернуть строку в английской кодировке

}//end eng()

/*-----------------------------------*\
|   Округление с заданной точностью   |
\*-----------------------------------*/
double EPSround(
	double x) {					//аргумент функции
	int buff;					//промежуточный результат

	//сохранение заданного количества знаков после запятой
	buff = round(x * (1 / EPS));
	
	return double(buff) / (1 / EPS);//вернуть результат

}//end EPSround()

/**********************   End of File CLASSES.СPP   *********************/